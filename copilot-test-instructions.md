# AI Unit Test Generation Guidelines for .NET with xUnit

## General Testing Principles

- **Arrange-Act-Assert (AAA)**: Structure tests with clear arrangement, action, and assertion sections
- **Single Responsibility**: Each test should verify one specific behavior or functionality
- **Isolation**: Tests should not depend on each other or external resources when possible
- **Deterministic**: Tests should produce the same result every time they run
- **Readable**: Test names and code should clearly indicate what is being tested

## xUnit Best Practices

### Test Structure

```csharp
[Fact] // or [Theory] for parameterized tests
public void MethodName_Scenario_ExpectedBehavior()
{
    // Arrange
    var sut = new SystemUnderTest();
    
    // Act
    var result = sut.MethodToTest();
    
    // Assert
    Assert.Equal(expected, result);
}
```

### Naming Conventions

- Use descriptive method names in the format: `MethodName_Scenario_ExpectedBehavior`
- Examples:
  - `GetProduct_ExistingId_ReturnsProduct`
  - `SaveProduct_NullProduct_ThrowsArgumentNullException`

### Assertion Types

- **Assert.Equal/NotEqual**: For value comparisons
- **Assert.True/False**: For boolean conditions
- **Assert.Null/NotNull**: For checking null values
- **Assert.Contains/DoesNotContain**: For collections
- **Assert.Throws/ThrowsAsync**: For exception testing
- **Assert.IsType/IsNotType**: For type checking

## Mocking Dependencies

- Use Moq or NSubstitute for mocking dependencies
- Mock only the interfaces that are directly used by the system under test
- Configure only the methods that will be called during the test

```csharp
// Example with Moq
var mockRepository = new Mock<IProductRepository>();
mockRepository.Setup(repo => repo.GetByIdAsync(1))
    .ReturnsAsync(new Product { Id = 1, Name = "Test Product" });
```

## Testing Patterns for Different Components

### Controllers

- Test status codes and response types
- Verify model validation behavior
- Test both successful and error scenarios

### Services

- Focus on business logic verification
- Test all possible branches and edge cases
- Mock external dependencies

### Repositories

- Use in-memory database for integration tests
- Test CRUD operations thoroughly
- Verify query filters work correctly

## Data Generation

- Use AutoFixture for generating test data
- Create helper methods for common test data setup
- Consider using factory patterns for complex object creation

## Parameterized Tests

```csharp
[Theory]
[InlineData(1, true)]
[InlineData(0, false)]
[InlineData(-1, false)]
public void IsPositive_WhenCalled_ReturnsExpectedResult(int input, bool expected)
{
    var result = MathHelper.IsPositive(input);
    Assert.Equal(expected, result);
}
```

## Async Testing

- Use async/await in test methods
- Apply `[Fact]` or `[Theory]` attributes (no special async attribute needed)
- Use `Assert.ThrowsAsync` for testing exceptions in async methods

## Coverage Goals

- Aim for high code coverage (>80%)
- Focus on testing edge cases and error conditions
- Ensure all business-critical paths are tested

## Implementing Robust Tests

- Use setup and cleanup methods when appropriate
- Apply test fixtures for shared resources
- Consider performance implications of tests
- Avoid testing implementation details when possible

<!-- Generated by Copilot -->